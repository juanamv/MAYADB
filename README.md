<!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  HEADER  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
# ğŸŒŒ  **M a y a D B**  ğŸŒŒ  

<pre>
â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    
â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   
â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   
â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   
â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   
â•šâ•â•     â•šâ•â• â•šâ•â•  â•šâ•â•      â•šâ•â•     â•šâ•â•  â•šâ•â•   â•šâ•â•â•â•â•â•    â•šâ•â•â•â•â•â•    
</pre>

> **MayaDB** es una base de datos especializada en autorizaciÃ³n y gestiÃ³n avanzada de accesos, inspirada en el modelo **GoogleÂ Zanzibar**.  
> DiseÃ±ada para simplificar reglas de acceso jerÃ¡rquicas y relaciones complejas, te permite administrar permisos **granulares**.
---

MayaDB es una base de datos especializada en autorizaciÃ³n y gestiÃ³n avanzada de accesos, inspirada en el modelo Google Zanzibar, reconocido por su efectividad y uso masivo en la infraestructura interna de Google. Esta soluciÃ³n ha sido creada para facilitar la administraciÃ³n de permisos granulares y relaciones complejas en aplicaciones modernas, simplificando significativamente el manejo de reglas de acceso sofisticadas y jerÃ¡rquicas.

## CaracterÃ­sticas principales

### Inspirado en Google Zanzibar

MayaDB adopta el modelo probado de Google Zanzibar, garantizando asÃ­ la fiabilidad y eficacia a gran escala. Esto permite manejar grandes volÃºmenes de relaciones y consultas de autorizaciÃ³n con alta eficiencia, tal como lo hacen aplicaciones globales lÃ­deres que requieren sistemas robustos y escalables.

### GestiÃ³n de Relaciones Complejas

La fortaleza de MayaDB reside en su capacidad para modelar y administrar relaciones altamente detalladas y flexibles. A travÃ©s de namespaces (espacios de nombres) y relaciones explÃ­citas, permite definir claramente cÃ³mo usuarios, roles, grupos y recursos interactÃºan entre sÃ­. Por ejemplo, es posible establecer permisos dinÃ¡micos donde un usuario puede acceder a ciertos documentos Ãºnicamente en contextos especÃ­ficos, dependiendo del rol, del grupo o incluso del estado interno del sistema.

### Escalabilidad y Rendimiento

DiseÃ±ada pensando en aplicaciones modernas con grandes demandas, MayaDB puede gestionar miles de solicitudes por segundo, proporcionando respuestas rÃ¡pidas con latencias muy bajas. Esta capacidad es esencial para aplicaciones crÃ­ticas que deben mantener un rendimiento constante independientemente de la carga o la cantidad de usuarios.

### API Flexible y FÃ¡cil IntegraciÃ³n

MayaDB ofrece una API clara y fÃ¡cil de usar, compatible tanto con REST como con su propio protocolo "maya", lo que simplifica la integraciÃ³n en diversos entornos de desarrollo y arquitecturas modernas como microservicios y sistemas distribuidos.

### Implementaciones Distribuidas y Replicadas

Aunque aÃºn en proceso de estabilizaciÃ³n para entornos productivos crÃ­ticos, MayaDB estÃ¡ diseÃ±ada para operar en entornos distribuidos, soportando configuraciones replicadas que eventualmente permitirÃ¡n alta disponibilidad y tolerancia a fallos.

## Casos de uso tÃ­picos

MayaDB es particularmente adecuada para aplicaciones que requieren un alto grado de precisiÃ³n y complejidad en la gestiÃ³n de permisos, tales como:

* **Aplicaciones Empresariales:** Para controlar accesos internos complejos y regulados, definiendo claramente roles, grupos y jerarquÃ­as internas.
* **Software colaborativo:** Aplicaciones que permiten compartir recursos (como documentos o proyectos) entre usuarios con niveles de permisos detallados y dinÃ¡micos.
* **Plataformas de Seguridad:** Donde es crucial el cumplimiento de estrictas regulaciones de privacidad y seguridad, como GDPR, HIPAA, o regulaciones financieras.

## InstalaciÃ³n

### Descargar ejecutables

1. Abre la pÃ¡gina de [Releases de MayaDB](https://github.com/juanamv/MAYADB/releases).  
2. Descarga el binario correspondiente a tu sistema operativo (Windows, Linux, macOS).  
3. Si viene en un comprimido (`.zip`, `.tar.gz`), descomprÃ­melo en la carpeta de tu elecciÃ³n.

---

### Generar certificados TLS (para conexiones seguras)

> **Importante:** Nunca compartas tu **clave privada** (`key.pem`). SÃ³lo distribuye el certificado pÃºblico (`cert.pem`).  
> **Importante:** Si tienes problemas al generar los certificados, puedes usar HTTP; en ese protocolo MayaDB no requiere certificados.

> **RecomendaciÃ³n (Â¡muy importante!):**
> Para **pruebas y desarrollo local**, se recomienda **HTTP**, ya que aunque el servidor QUIC estÃ¡ listo, **el cliente oficial aÃºn estÃ¡ en desarrollo**. Si no cuentas con certificados o necesitas la mÃ­nima fricciÃ³n, trabaja sobre HTTP y omite la creaciÃ³n de `cert.pem`/`key.pem`.

#### Par auto-firmado (pruebas)

```bash
openssl req -x509 -newkey rsa:2048 \
  -keyout key.pem     \
  -out cert.pem       \
  -days 365           \
  -nodes              \
  -subj "/CN=localhost"
chmod 600 key.pem
````

* `key.pem`: clave privada (permiso `600`).
* `cert.pem`: certificado pÃºblico (compartible).

---

### Configurar variables de entorno

MayaDB necesita dos credenciales de inicio:

* `MAYA_USER`
* `MAYA_PASS`

#### Linux / macOS (bash, zshâ€¦)

Edita tu `~/.bashrc` o `~/.zshrc`:

```bash
export MAYA_USER="tu_usuario"
export MAYA_PASS="tu_contraseÃ±a_segura"
```

Luego:

```bash
source ~/.bashrc   # o ~/.zshrc
```

#### Windows

##### Interfaz grÃ¡fica
1. Abre el menÃº **Inicio** y busca **Variables de entorno** â†’ selecciona **Editar las variables de entorno del sistema**.
2. Haz clic en **Variables de entornoâ€¦**.
3. Bajo **Variables de usuario** (o **Variables del sistema** si lo prefieres), pulsa **Nuevaâ€¦**.

   * **Nombre de la variable**: `MAYA_USER`
   * **Valor de la variable**: `tu_usuario`
4. Repite **Nuevaâ€¦** para `MAYA_PASS` con tu contraseÃ±a.


##### PowerShell (Usuario)

```powershell
[Environment]::SetEnvironmentVariable(
  "MAYA_USER", "tu_usuario", "User"
)
[Environment]::SetEnvironmentVariable(
  "MAYA_PASS", "tu_contraseÃ±a_segura", "User"
)
```

Abre una nueva consola para aplicar.

##### CMD

```cmd
setx MAYA_USER "tu_usuario"
setx MAYA_PASS "tu_contraseÃ±a_segura"
```

Abre una nueva ventana de CMD.

---

### Ejecutar MayaDB

Desde la carpeta donde estÃ© el binario (`mayadb` o `mayadb.exe`):

```bash
./mayadb
```

Y ya tendrÃ¡s tu servidor MayaDB corriendo con TLS y credenciales en entorno.

> **Nota:**
>
> * En el repositorio hay un `env.json` para cambiar `protocol` entre `http` o `quic`.
> * Si modificas `protocol`, reinicia el servicio.

#### InicializaciÃ³n con parÃ¡metros CLI (nuevo flujo)

Ahora el binario acepta sobreescritura directa desde la lÃ­nea de comandos. Esto permite ajustar el servicio sin editar `env.json` ni depender exclusivamente de variables de entorno.

ParÃ¡metros soportados:

| Flag                    | DescripciÃ³n                                                                                | Predeterminado                |
|-------------------------|--------------------------------------------------------------------------------------------|-------------------------------|
| `--port <u16>`          | Puerto de escucha.                                                                         | `8080` (HTTP) / `5000` (QUIC) |
| `--protocol <http|quic>`| Protocolo expuesto. Se recomienda `http` en desarrollo.                                   | `quic`                        |
| `--host <cadena>`       | DirecciÃ³n de enlace (`127.0.0.1`, `0.0.0.0`, hostname).                                   | `localhost`                   |
| `--path <ruta>`         | Carpeta para LMDB. Se crea si no existe.                                                  | `./MAYA_DB`                   |
| `--user <cadena>`       | Usuario root inicial (sustituye `MAYA_USER`).                                             | cadena vacÃ­a                  |
| `--pass <cadena>`       | ContraseÃ±a root inicial (sustituye `MAYA_PASS`).                                          | cadena vacÃ­a                  |
| `--max-readers <u32>`   | LÃ­mite de lectores LMDB concurrentes.                                                     | `512`                         |
| `--map-size <bytes>`    | TamaÃ±o mÃ¡ximo del mapa LMDB (en bytes).                                                   | valor por defecto interno     |
| `--generate-certs`      | Si se especifica, genera `cert.pem`/`key.pem` y finaliza sin levantar el servidor.        | `false`                       |

Ejemplo de arranque personalizado:

```bash
./mayadb \
  --protocol http \
  --port 8080 \
  --host 0.0.0.0 \
  --path ./MAYA_DB \
  --user admin \
  --pass "admin-secret"
```

Otros escenarios comunes:

- **CLI mÃ­nima (solo HTTP, credenciales embebidas):**

  ```bash
  ./mayadb --protocol http --user root --pass root
  ```

- **Servidor QUIC en puerto 5001, directorio dedicado:**

  ```bash
  ./mayadb \
    --protocol quic \
    --port 5001 \
    --path /var/lib/mayadb \
    --user quic_admin \
    --pass "quic-secret"
  ```

- **Modo generaciÃ³n de certificados (no levanta servicio):**

  ```bash
  ./mayadb --generate-certs
  # Resultado: cert.pem y key.pem en el directorio actual.
  ```

Si omites un flag, se utilizan los valores de `env.json` o los predeterminados en el binario. Esta modalidad facilita automatizaciones en contenedores, pipelines y entornos multi-stage.

---

### Probar conexiÃ³n (HTTP)

Si estÃ¡s usando **HTTP**, puedes usar cualquier cliente REST (Postman, cURL, etc.):

* **MÃ©todo:** `POST`
* **URL:**

  ```
  http://<host>:<puerto>/q-exec
  ```
* **Body (JSON):**

  ```json
  {
    "version":    "1",
    "user":       "root",
    "password":   "root",
    "db_name":    "dbname",
    "db_version": "1.1:alpha",
    "query":      "Consulta"
  }
  ```

1. Abre Postman (o tu cliente favorito).
2. Selecciona `POST` e introduce la URL `http://localhost:3000/q-exec` (ajusta host/puerto).
3. En la pestaÃ±a **Body**, elige `raw` â†’ `JSON` y pega el JSON de ejemplo.
4. EnvÃ­a la peticiÃ³n y revisa la respuesta.


## Uso BÃ¡sico

MayaDB utiliza un lenguaje llamado CLRA (Custom Language for Relations and Authorization) para definir esquemas claros y estructurados. Estos esquemas permiten especificar de manera precisa cÃ³mo estÃ¡n organizados los recursos, los usuarios y sus relaciones dentro del sistema.

### Definir un esquema con CLRA

Para iniciar con MayaDB, debes definir claramente un esquema que represente las entidades y relaciones especÃ­ficas de tu aplicaciÃ³n.

Ejemplo bÃ¡sico de esquema:

```clra
db: dbname;
version: 1.1:alpha;

ns User {
    self;
};

ns Group {
    relation owner = User::self;
};

ns Task {
    relation assignee = Group::member;
};
```

### Componentes de un esquema

#### Headers

Los encabezados definen el contexto general del esquema, estableciendo dos elementos fundamentales:

```clra
db: dbname;
version: 1.1:alpha;
```

* `db`: Indica el nombre de la base de datos interna en la cual el esquema serÃ¡ aislado.
* `version`: Define la versiÃ³n del esquema, permitiendo gestionar evoluciones y cambios futuros del esquema sin conflictos.

#### Namespace

Los namespaces (espacios de nombres) son elementos fundamentales en CLRA que agrupan propiedades y relaciones. Se utilizan para definir claramente las entidades que se gestionarÃ¡n en MayaDB:

```clra
ns User {
    self;
};
```

* `ns`: Define un espacio de nombres (namespace).
* `User`: Es el nombre del namespace, que debe iniciar siempre con una letra mayÃºscula.
* `self;`: Palabra reservada que indica que la referencia de este namespace apunta directamente hacia sÃ­ misma. Esto implica que es un nodo inicial o final, lo que evita que se creen relaciones adicionales directamente desde este namespace.

#### Relations

Las relaciones especifican cÃ³mo los diferentes namespaces interactÃºan y se conectan entre sÃ­. Se utilizan para definir dependencias claras y permisos jerÃ¡rquicos:

Ejemplo:

```clra
ns Group {
    relation owner = Group::self;
};
```

* `relation`: Palabra clave para definir una relaciÃ³n.
* `owner`: Nombre dado a la relaciÃ³n, que especifica claramente el tipo de interacciÃ³n o propiedad entre namespaces.
* `Group::self`: Define que esta relaciÃ³n apunta especÃ­ficamente a una entidad del namespace `Group`.

Se pueden crear relaciones mÃ¡s complejas utilizando operadores lÃ³gicos como `|` para especificar mÃºltiples posibles entidades vÃ¡lidas para una relaciÃ³n:

```clra
relation owner = Group::owner | User::self;
```

* AquÃ­ se establece claramente que la entidad `owner` puede referirse a un propietario del namespace `Group` o directamente a un usuario del namespace `User`. Esto permite validar y gestionar permisos complejos con mayor flexibilidad y precisiÃ³n.

#### JSON Types

Los `JSON Types` permiten definir claramente metadatos adicionales en un namespace, facilitando la gestiÃ³n y el almacenamiento de informaciÃ³n complementaria que no necesariamente forma parte directa de las relaciones, pero que sÃ­ es Ãºtil o necesaria dentro del contexto de una entidad.

Ejemplo de definiciÃ³n:

```clra
json types {
    name: string required default = "name";
    age: number required;
    email: string required default = "example@example.com" email_format;
};
```

* **name**: Este campo es una cadena de texto (`string`), requerido, y posee un valor predeterminado de "name".
* **age**: Campo numÃ©rico (`number`), requerido, que debe proporcionarse explÃ­citamente al crear o actualizar una entidad.
* **email**: Cadena de texto (`string`) requerida con un valor predeterminado especÃ­fico, que ademÃ¡s tiene una restricciÃ³n adicional: debe cumplir un formato vÃ¡lido de correo electrÃ³nico. MayaDB verificarÃ¡ automÃ¡ticamente esta condiciÃ³n antes de aceptar cualquier entidad que use este campo.

##### Ventajas de los JSON Types

* **Eficiencia y rapidez:** Permiten almacenar informaciÃ³n Ãºtil directamente dentro del namespace, evitando la necesidad de mantener una base de datos adicional y sincronizarla constantemente.
* **Accesibilidad universal:** Estos metadatos estÃ¡n disponibles desde cualquier punto de la base de datos, simplificando considerablemente las consultas que requieran informaciÃ³n contextual adicional.
* **Flexibilidad:** Aunque no son obligatorios, su uso permite definir claramente quÃ© informaciÃ³n adicional puede o debe acompaÃ±ar a cada entidad, facilitando validaciones mÃ¡s complejas y precisas.

##### Tipos de datos soportados

MayaDB maneja estrictamente los siguientes tipos de datos en los `JSON Types`:

* `string`: texto o cadenas de caracteres.
* `number`: nÃºmeros (no distingue entre enteros y decimales).
* `boolean`: valores verdaderos o falsos.
* `array`: listas homogÃ©neas de elementos del mismo tipo.
* `object`: estructuras mÃ¡s complejas que pueden contener mÃºltiples campos internos.

Debido a que no existen tipos especÃ­ficos como `int` o `float`, se recomienda usar `number` para cualquier dato numÃ©rico. AdemÃ¡s, los arrays deben ser homogÃ©neos, es decir, todos los elementos deben ser del mismo tipo.

##### Buenas prÃ¡cticas y recomendaciones

* **Evitar estructuras demasiado complejas:** Aunque es posible anidar objetos dentro de arrays y viceversa, se recomienda limitar la complejidad de las estructuras para facilitar las actualizaciones frecuentes y agilizar las consultas.
* **Mantener la informaciÃ³n en primer nivel:** MayaDB indexa eficientemente los campos en el nivel superior del JSON. Por lo tanto, los datos que necesitan actualizaciones constantes o rÃ¡pidas deben mantenerse lo mÃ¡s cerca posible del nivel raÃ­z.
* **ValidaciÃ³n estricta:** MayaDB realiza automÃ¡ticamente comprobaciones estrictas en la creaciÃ³n de entidades. Si se proporciona un dato con un tipo incorrecto o en un formato invÃ¡lido, MayaDB retornarÃ¡ un error claro, asegurando asÃ­ la consistencia y la integridad de los datos.


### Annotations \[check]

Las anotaciones `@check` permiten implementar validaciones avanzadas y especÃ­ficas en las relaciones definidas dentro de los namespaces. Estas anotaciones facilitan la creaciÃ³n de reglas de acceso condicionales y dinÃ¡micas basadas en estados internos, roles de usuarios, o condiciones ambientales.

Ejemplo de anotaciÃ³n con validaciones avanzadas:

```clra
ns User {
    relation owner = User::self @check{
        AllowIf: ($role == "admin" OR $role == "moderator") AND #system.status == "active"
        DenyIf: NOT (::resource.permissions NOT_IN $user.permissions)
    }
};
```

#### ExplicaciÃ³n detallada del ejemplo:

* **AllowIf:** Esta condiciÃ³n permite que la relaciÃ³n exista Ãºnicamente si el usuario tiene un rol especÃ­fico (`admin` o `moderator`) y el sistema estÃ¡ activo (`#system.status == "active"`).
* **DenyIf:** Esta condiciÃ³n niega automÃ¡ticamente la relaciÃ³n si los permisos del recurso estÃ¡n incluidos en los permisos del usuario (la lÃ³gica de doble negaciÃ³n se utiliza aquÃ­ para demostrar flexibilidad en validaciones complejas).

#### Orden y flujo de ejecuciÃ³n:

Las validaciones en `@check` siguen un flujo predeterminado basado en el principio de **"Implicit Deny"**, lo cual significa que, por defecto, todas las relaciones se deniegan a menos que explÃ­citamente se permitan. Por lo tanto, aunque en el ejemplo anterior la condiciÃ³n `AllowIf` estÃ¡ escrita antes de `DenyIf`, en realidad el flujo interno es:

1. Primero se evalÃºa siempre la condiciÃ³n `DenyIf`. Si esta condiciÃ³n es verdadera, la relaciÃ³n se deniega inmediatamente, sin evaluar `AllowIf`.
2. Luego se evalÃºa la condiciÃ³n `AllowIf`. Si esta condiciÃ³n se cumple, la relaciÃ³n es permitida.
3. Si ninguna de las condiciones anteriores se cumple, la relaciÃ³n se deniega por defecto.

#### Acceso a informaciÃ³n adicional:

Las anotaciones permiten acceder a diversos tipos de informaciÃ³n para realizar validaciones mÃ¡s complejas:

* **Variables de entorno (`#system`)**: Puedes consultar estados globales del sistema, por ejemplo, si el sistema estÃ¡ activo o en mantenimiento. Estas variables siempre son consideradas tipo "string".
* \*\*\*\*Metadatos del namespace (`::`)\*\*: Permite acceder directamente a los datos almacenados previamente como `JSON Types` dentro del namespace consultado, facilitando la verificaciÃ³n de informaciÃ³n especÃ­fica de entidades o datos guardados previamente.
* **Metadatos de usuario (`$user`)**: Se pueden utilizar datos adicionales enviados al momento de realizar la consulta, como permisos o roles especÃ­ficos asignados al usuario actual.

#### Precauciones y recomendaciones:

* **Uso moderado de variables de entorno:** Cada consulta de variables ambientales implica una interacciÃ³n adicional con el sistema, lo que puede afectar negativamente el rendimiento en sistemas con alta carga o muchas peticiones simultÃ¡neas.
* **Profundidad de relaciones:** Dado que cada validaciÃ³n se ejecuta secuencialmente en todas las relaciones involucradas, se recomienda mantener un control sobre la profundidad y complejidad de las relaciones para evitar impactos negativos en el rendimiento.
* **Metadatos JSON:** Durante las validaciones, es posible enviar metadatos serializados en formato JSON estÃ¡ndar que pueden ser utilizados en `@check` para realizar validaciones aÃºn mÃ¡s precisas y complejas.

#### Sintaxis utilizada en `@check`:

* **`AllowIf`**: Define una condiciÃ³n especÃ­fica bajo la cual la relaciÃ³n serÃ¡ explÃ­citamente permitida.
* **`DenyIf`**: Establece condiciones especÃ­ficas bajo las cuales la relaciÃ³n serÃ¡ explÃ­citamente denegada.
* **`#system`**: Permite acceder a variables ambientales o del sistema.
* **`::resource`**: Permite acceder a metadatos especÃ­ficos del recurso dentro del namespace actual.
* **`$user`**: Permite acceder a informaciÃ³n adicional sobre el usuario, enviada al realizar la consulta.


### Annotations \[script] (Experimental)

Las anotaciones `@script` permiten realizar validaciones avanzadas mediante scripts personalizados escritos en JavaScript, facilitando escenarios complejos o especÃ­ficos que no pueden manejarse con la validaciÃ³n estÃ¡ndar (`@check`). Actualmente, esta caracterÃ­stica es experimental y no se recomienda utilizarla en entornos de producciÃ³n.

Ejemplo bÃ¡sico de anotaciÃ³n con script:

```clra
ns User {
    relation owner = User::self @script{
        async main() {
            // AquÃ­ puedes escribir JavaScript asÃ­ncrono para validaciones avanzadas.
        }
    }
};
```

#### Casos de uso para scripts

Los scripts son especialmente Ãºtiles en casos en los que:

* Se requieren validaciones dependientes de condiciones externas.
* Es necesario consultar informaciÃ³n desde bases de datos externas o servicios API externos.
* Se debe actualizar dinÃ¡micamente el estado de namespaces o recursos.

#### Funcionamiento y precauciones

* **Naturaleza no determinista:** El uso de scripts rompe con el principio de validaciones deterministas, ya que su resultado puede variar dependiendo de factores externos, como respuestas de servicios remotos o cambios en otras bases de datos.
* **Rendimiento:** La ejecuciÃ³n de scripts es significativamente mÃ¡s lenta en comparaciÃ³n con las validaciones en `@check`, debido al tiempo que requiere iniciar y ejecutar cÃ³digo JavaScript dentro de una mÃ¡quina virtual.
* **GestiÃ³n de estado:** MayaDB puede reutilizar la mÃ¡quina virtual JavaScript para diferentes ejecuciones, lo que implica un riesgo de que los datos residuales de ejecuciones anteriores afecten validaciones posteriores. Por ello, es crucial asegurarse de que los scripts limpien o sobrescriban cualquier estado temporal para mantener la integridad y consistencia de los resultados.

#### Buenas prÃ¡cticas

* **No almacenar datos persistentes en scripts:** Evita mantener cualquier estado temporal o datos permanentes en la ejecuciÃ³n del script para prevenir contaminaciÃ³n cruzada entre ejecuciones.
* **LimitaciÃ³n en el uso:** Reserva los scripts para escenarios especÃ­ficos que requieren una lÃ³gica particularmente compleja o dependiente de recursos externos, y utiliza las anotaciones `@check` para validaciones regulares o deterministas.
* **Monitoreo y auditorÃ­a:** Debido a su naturaleza experimental, implementa monitoreo exhaustivo y auditorÃ­as regulares de cualquier uso de scripts, asegurando que no introduzcan vulnerabilidades o problemas de rendimiento inesperados en tu sistema.

#### ImplementaciÃ³n de APIs (PrÃ³xima versiÃ³n)

Hasta ahora, la anotaciÃ³n `@script` no dispone de una API pÃºblica para interactuar directamente con MayaDB ni realizar peticiones HTTP desde JavaScript. Esto significa que los scripts no pueden, en su estado actual, consultar ni modificar datos de la base de datos ni comunicarse con servicios externos. **A partir de MayaDBÂ 0.2.0** se aÃ±adieron los helpers descritos en la secciÃ³n â€œAPIs JavaScript embebidas (beta)â€, pero permanecen limitados a operaciones de lectura y no habilitan escritura ni llamadas HTTP externas.

En la siguiente versiÃ³n de MayaDB se incluirÃ¡n:

* **API REST**: Endpoints dedicados para invocar y gestionar la ejecuciÃ³n de scripts de validaciÃ³n de forma segura y controlada.
* **SDK JavaScript**: Un paquete cliente que expondrÃ¡ mÃ©todos asincrÃ³nicos para:

  * Cargar y ejecutar scripts de validaciÃ³n.
  * Acceder a metadatos de entidades dentro de namespaces.
  * Realizar llamadas a servicios externos respetando las polÃ­ticas de ejecuciÃ³n de MayaDB.

Estas nuevas APIs estarÃ¡n diseÃ±adas para integrarse de manera nativa con la anotaciÃ³n `@script`, permitiendo que el cÃ³digo JavaScript pueda:

1. Consultar metadatos de namespaces a travÃ©s de llamadas asincrÃ³nicas.
2. Invocar endpoints internos para validar parte del flujo de autorizaciÃ³n.
3. Realizar peticiones HTTP seguras hacia servicios externas, manteniendo aislamiento e integridad.

Mientras llegan estas funcionalidades, mantÃ©n los scripts limitados a validaciones puramente lÃ³gicas y planea la transiciÃ³n de las validaciones mÃ¡s complejas a las nuevas APIs cuando estÃ©n disponibles.


#### DefiniciÃ³n de tipos (`json types`)

```clra
json types {
    name:  string required  default = "name";
    age:   number required;
    email: string required  default = "example@example.com" email_format;
}
```

* **name**â€ƒ Cadena obligatoria. Valor por defectoÂ `"name"`.
* **age**â€ƒâ€ƒ NÃºmero obligatorio.
* **email**â€ƒCadena obligatoria en formato eâ€‘mail. Valor por defectoÂ `"example@example.com"`.

---

### Operaciones sobre entidades

Las entidades viven dentro de un *namespace* y se identifican por un ID Ãºnico (`Namespace::ID`). MayaDB no estÃ¡ pensado para realizar consultas complejas; las operaciones son directas sobre una entidad completa.

#### Crear una entidad

```clra
ENTITY CREATE Video::videoID { name: "user123", age: 1 }
```

* **`ENTITY CREATE`**

  * `Video` â†’ namespace
  * `videoID` â†’ ID de la entidad
  * `{ â€¦ }` â†’ metadatos iniciales

---

#### Leer una entidad

```clra
ENTITY GET Video::videoID
```

Devuelve todos los metadatos almacenados para la entidad. No admite filtros ni proyecciones.

---

#### Actualizar una entidad

```clra
ENTITY UPDATE Namespace::ID SET name = "IronÂ Man";
ENTITY UPDATE Namespace::ID SET age = 42, active = true;
```

La clÃ¡usula `SET` acepta:

| Tipo de operaciÃ³n                             | Ejemplo                              |
| --------------------------------------------- | ------------------------------------ |
| AsignaciÃ³n directa                            | `name = "Iron Man"`                  |
| MÃºltiples asignaciones                        | `age = 42, active = true`            |
| Incremento / decremento numÃ©rico              | `stats.score += -7.5`                |
| Operaciones aritmÃ©ticas con expresiones       | `measure /= (sum.total - 3.14)`      |
| ManipulaciÃ³n de arrays                        | `inventory.items[3].qty -= 1`        |
| Appendix / prepend / pop / shift / remove     | `users[*].tags APPEND ["new","vip"]` |
| AsignaciÃ³n masiva con comodÃ­n (`*`)           | `*.status = "pending"`               |

> **Nota:** Las rutas tipo `matrix.rows[0].values`, rangos `[1:3]`, comodines `[*]` y operadores sobre listas (`POP`, `SHIFT`, `REMOVE`, etc.) permiten actualizaciones muy especÃ­ficas dentro de estructuras JSON anidadas.

---

#### Eliminar una entidad

```clra
ENTITY DELETE Team::teamID
```

Borra por completo la entidad indicada. Al igual que con `GET`, hay que especificar el *namespace* y el ID de forma explÃ­cita.

---

#### Comandos

| AcciÃ³n     | Sintaxis bÃ¡sica                     |
| ---------- | ----------------------------------- |
| Crear      | `ENTITY CREATE Namespace::ID { â€¦ }` |
| Leer       | `ENTITY GET    Namespace::ID`       |
| Actualizar | `ENTITY UPDATE Namespace::ID SET â€¦` |
| Eliminar   | `ENTITY DELETE Namespace::ID`       |

Cada comando actÃºa sobre **una Ãºnica entidad**; MayaDB no soporta bÃºsquedas, filtros ni uniones entre entidades.


### GestiÃ³n de **Links**

Los *links* son bordes en el grafo de MayaDB: conectan entidades que viven en *namespaces* distintos y expresan la **relaciÃ³n** que existe entre ellas. Por diseÃ±o, un link:

* **Indica direcciÃ³n**â€ƒ`OrigenÂ â†’ relaciÃ³nÂ â†’Â Destino`
* **Puede caducar**â€ƒâ€ƒTTL (Timeâ€‘toâ€‘Live) opcional
* **No se edita**â€ƒâ€ƒâ€ƒSi la relaciÃ³n cambia, se borra y se crea de nuevo

Cuando MayaDB evalÃºa permisos (`LINKÂ GET`), recorre estos bordes para deducir si un actor tiene derecho sobre un recurso. Las secciones siguientes explican cada operaciÃ³n con sintaxis, reglas y ejemplos completos.

---

#### Crear un link (`LINKÂ CREATE`)

```clra
LINK CREATE User::Alice.user -> owner -> Group::Engineering WITH TTL "1d"
```

| Elemento             | Significado                                            |
| -------------------- | ------------------------------------------------------ |
| `User::Alice.user`   | **Origen**â€‚(namespace `User`, id `Alice`, tipo `user`) |
| `owner`              | **RelaciÃ³n** (nombre lÃ³gico definido en el esquema)    |
| `Group::Engineering` | **Destino**â€‚(namespace `Group`, id `Engineering`)      |
| `TTL "1d"`           | El link expira 24 h despuÃ©s de su creaciÃ³n             |

**Por quÃ© usar TTL**
En vÃ­nculos temporales â€•por ejemplo, acceso a un proyecto durante un *sprint*â€• basta con fijar la caducidad y olvidar limpiezas manuales; MayaDB invalidarÃ¡ el borde automÃ¡ticamente.

> **Reglas de creaciÃ³n**
>
> * El par Origenâ€‘Destino **ya debe existir**; no se crean entidades implÃ­citas.
> * El nombre de la relaciÃ³n debe coincidir con el declarado en el esquema (`ns â€¦ { relation â€¦ }`).
> * El TTL se escribe en notaciÃ³n ISOâ€‘8601 restringida (`"72h"`, `"30m"`, etc.) o como fecha absoluta (`"2025â€‘05â€‘20T12:00:00Z"`).

---

#### Actualizar un link

No estÃ¡ permitido. Para cambiar la relaciÃ³n:

1. `LINK DELETE â€¦`
2. `LINK CREATE â€¦` con los parÃ¡metros nuevos

Prohibir ediciones evita ciclos de vida incoherentes y simplifica la verificaciÃ³n de permisos (un link es siempre **atÃ³mico**: existe o no).

---

#### Eliminar un link (`LINKÂ DELETE`)

```clra
LINK DELETE User::Alice.user -> owner -> Group::Engineering
```

Borra la arista que enlaza `Alice` con `Engineering` bajo la relaciÃ³n `owner`. Si el link habÃ­a caducado, esta orden lo elimina igualmente (idempotente).

---

#### Listar links (`LINKÂ LIST`)

```clra
LINK LIST FROM User::Alice.user
```

Devuelve **todas** las relaciones salientes desde `User::Alice.user` que sigan vigentes. No existen filtros por tipo de relaciÃ³n ni por destino; la intenciÃ³n es obtener el â€œpanel de controlâ€ completo de la entidad origen.

---

#### Resolver permisos (`LINKÂ GET`)

##### Concepto

`LINKÂ GET` es la consulta de **autorizaciÃ³n** en MayaDB. Busca un camino vÃ¡lido (orientado y no caducado) entre el origen y el destino a travÃ©s de las relaciones declaradas, aplicando las reglas y las anotaciones `@check` que encuentre en cada salto.

##### Ejemplo completo

```clra
-- ConstrucciÃ³n del grafo
LINK CREATE User::Alice.user           -> owner   -> Group::Engineering;
LINK CREATE Group::Engineering.owner   -> admin   -> Team::Platform;
LINK CREATE Team::Platform.admin       -> member  -> Project::Apollo;
LINK CREATE Project::Apollo.member     -> assignee -> Task::Deploy;

-- Consulta de permiso
LINK GET User::Alice.user -> assignee -> Task::Deploy
```

**Lectura paso a paso**

| Salto | RelaciÃ³n   | Se evalÃºaâ€¦                              | Resultado   |
| ----- | ---------- | --------------------------------------- | ----------- |
| 1     | `owner`    | Â¿Existe link que no haya expirado?      | âœ”ï¸          |
| 2     | `admin`    | Idem + reglas `@check` en `Team::admin` | (ver abajo) |
| 3     | `member`   | â€¦                                       | âœ”ï¸          |
| 4     | `assignee` | â€¦                                       | âœ”ï¸          |

Si **todos** los eslabones dan positivo, la respuesta global es â€œPermitidoâ€.

#### EvaluaciÃ³n de anotaciones `@check`

Esquema simplificado:

```clra
ns Team {
    relation admin = Group::owner @check{
        AllowIf: (::name == "team_name")
        DenyIf:  (::projects_count == 0)
    };
}
```

* MayaDB ejecuta el bloque `@check` **en el momento** de cruzar el borde.
* Las expresiones se evalÃºan sobre los metadatos de la entidad destino (`Team::Platform`).
* Si alguna regla `DenyIf` se cumple, el camino queda anulado y `LINKÂ GET` devuelve *Denied*.

---

#### Buenas prÃ¡cticas al modelar relaciones

1. **Nombrar las relaciones con semÃ¡ntica de permisos** (p.ej. `owner`, `admin`, `viewer`).
2. **Usar TTL para accesos acotados** (demostraciones, tareas puntuales).
3. **Aislar reglas de negocio en `@check`** en vez de hardâ€‘codear lÃ³gica en la aplicaciÃ³n cliente.
4. **Mantener las entidades pequeÃ±as**: los filtros `@check` se ejecutan sobre los metadatos; si Ã©stos son livianos, la verificaciÃ³n es rÃ¡pida.
5. **Registrar la versiÃ³n del esquema** (`version: 1.1:alpha`) para trazar cambios en producciÃ³n.

---

#### Resumen operativo

| AcciÃ³n            | Comando                                | Notas clave                                 |
| ----------------- | -------------------------------------- | ------------------------------------------- |
| Crear link        | `LINK CREATE A -> rel -> B [WITH TTL]` | TTL opcional                                |
| Eliminar link     | `LINK DELETE A -> rel -> B`            | Idempotente                                 |
| Listar links      | `LINK LIST FROM A`                     | Sin filtros adicionales                     |
| Verificar permiso | `LINK GET A -> relFinal -> C`          | Recorre mÃºltiple saltos con reglas `@check` |
| Cambiar relaciÃ³n  | `DELETE` â†’ `CREATE`                    | Actualizar **no** estÃ¡ soportado            |

Con esta estructura podrÃ¡s describir, inspeccionar y depurar la autorizaciÃ³n basada en grafos de MayaDB de manera consistente y transparente.

---

## APIs JavaScript embebidas (beta)

Aunque la secciÃ³n anterior mencionaba la ausencia de una API pÃºblica para scripts, desde **MayaDBÂ 0.2.0** se expone un conjunto limitado de helper functions pensadas exclusivamente para lectura. El runtime sigue en fase **BETA**, por lo que la interfaz puede cambiar sin previo aviso y no se garantiza compatibilidad hacia atrÃ¡s.

### Funciones disponibles

| Helper                              | ParÃ¡metros (JSON/string)                                                                 | Resultado                                          |
|--------------------------------------|-------------------------------------------------------------------------------------------|----------------------------------------------------|
| `await fetchKey(key)`                | Cadena con la clave LMDB exacta.                                                          | Cadena con el contenido bruto.                     |
| `await fetchLinkForward(payload)`    | JSON serializado con `db`, `version`, `code`, `from_namespace`, `from_entity`, `from_role`, `to_namespace`, `to_entity`, `relation`.| JSON string con TTL (`ttl`), `from`, `to`, `relation`. |
| `await fetchEntityData(payload)`     | JSON con `db`, `version`, `code`, `namespace`, `entity`.                                 | JSON string con los atributos almacenados.         |

Ejemplo de uso dentro de `@script` (recordar que el script debe exportar `async function main()`):

```javascript
async function main() {
  const entity = JSON.parse(await fetchEntityData(JSON.stringify({
    db: "demo",
    version: "1",
    code: "alpha",
    namespace: "User",
    entity: "alice"
  })));

  if (entity.status !== "active") {
    return { authorized: false, value: { reason: "inactive" } };
  }

  const link = JSON.parse(await fetchLinkForward(JSON.stringify({
    db: "demo",
    version: "1",
    code: "alpha",
    from_namespace: "User",
    from_entity: "alice",
    from_role: "owner",
    to_namespace: "Group",
    to_entity: "engineering",
    relation: "member"
  })));

  return { authorized: true, value: { entity, link } };
}
```

### Consideraciones y limitaciones

- **Solo lectura**: actualmente no hay helpers para crear, actualizar o eliminar datos desde JS.
- **Errores propagados**: si se consulta una clave inexistente, se recibe un error JavaScript (capturable con `try/catch`).
- **Estado compartido**: el motor puede reciclar instancias; evita almacenar datos en variables globales.
- **Rendimiento**: cada helper ejecuta operaciones LMDB y serializaciones JSON; Ãºsalos con moderaciÃ³n.

> **Importante**: debido a que el runtime JS continÃºa en beta, se recomienda limitar su uso a prototipos o decoradores ligeros y mantener la lÃ³gica principal en `@check` o en la aplicaciÃ³n cliente.
